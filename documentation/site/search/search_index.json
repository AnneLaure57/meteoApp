{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Nom du projet TP3 - M\u00e9t\u00e9o App : une application de pr\u00e9visions m\u00e9t\u00e9o. Livrable \u00c0 rendre : une distribution source, une distribution binaire, une documentation compl\u00e8te. Description de l'application Ce projet correspond au TP3 r\u00e9alis\u00e9 lors du cours de programation objet avanc\u00e9e en Master 1 MIAGE. L'application permet \u00e0 partir de l'interface interactive (con\u00e7ue en JAVA FX) de : d'avoir la m\u00e9t\u00e9o d'une ville pour le jour courant, d'avoir les pr\u00e9visions pour les 4 prochains jours, de pouvoir rafra\u00eechir les pr\u00e9visions toutes les X minutes, de pouvoir personnaliser l'affichage des donn\u00e9es du jour courant, de pouvoir cr\u00e9er une liste personnalis\u00e9e (une liste avec les villes et pays), sauvegarder et r\u00e9actualiser cette liste. Auteur Anne-Laure CHARLES - M1 MIAGE - Parcours Alternance","title":"Accueil"},{"location":"index.html#nom-du-projet","text":"TP3 - M\u00e9t\u00e9o App : une application de pr\u00e9visions m\u00e9t\u00e9o.","title":"Nom du projet"},{"location":"index.html#livrable","text":"\u00c0 rendre : une distribution source, une distribution binaire, une documentation compl\u00e8te.","title":"Livrable"},{"location":"index.html#description-de-lapplication","text":"Ce projet correspond au TP3 r\u00e9alis\u00e9 lors du cours de programation objet avanc\u00e9e en Master 1 MIAGE. L'application permet \u00e0 partir de l'interface interactive (con\u00e7ue en JAVA FX) de : d'avoir la m\u00e9t\u00e9o d'une ville pour le jour courant, d'avoir les pr\u00e9visions pour les 4 prochains jours, de pouvoir rafra\u00eechir les pr\u00e9visions toutes les X minutes, de pouvoir personnaliser l'affichage des donn\u00e9es du jour courant, de pouvoir cr\u00e9er une liste personnalis\u00e9e (une liste avec les villes et pays), sauvegarder et r\u00e9actualiser cette liste.","title":"Description de l'application"},{"location":"index.html#auteur","text":"Anne-Laure CHARLES - M1 MIAGE - Parcours Alternance","title":"Auteur"},{"location":"installation.html","text":"\u00c9x\u00e9cuter l'application Pr\u00e9-requis Pour pouvoir utiliser cette application, que vous soyez sur Linux, MAC OS ou Windows, vous devez installer ou poss\u00e9der JAVA JDK8 . Distribution source Depuis le fichier source Il faut t\u00e9l\u00e9charger la distrubution source qui a \u00e9t\u00e9 d\u00e9pos\u00e9 sur Arche TP3-CHARLES-meteo-0.0.1-SNAPSHOT-project.zip. Voici l'arborescence du projet, une fois d\u00e9zipp\u00e9 : Depuis GitHub Pour r\u00e9cup\u00e9rer les fichiers sources depuis le d\u00e9p\u00f4t GIT, il vous faut d'abord cloner ou t\u00e9l\u00e9charger sous format zip : Pour cloner en SSH Pour cloner en HTTP Il ne vous reste plus qu'\u00e0 importer votre projet depuis un IDE tel que Eclipse ou IntellJ par exemple. Arborescence scripts/bin : contient les fichiers ex\u00e9cutables (distribution binaire) ; src/main/java/fr/ul/miage/ : contient le code Java (voir Manuel technique). Executer le programme Lancer un utilitaire de commandes : Sous Windows : une invite de commandes Sous Linux/Unix/Mac : un terminal \u00c0 l'aide de la commande cd , rendez-vous dans le r\u00e9pertoire o\u00f9 se trouve le .bat , ou ouvrez directement l'utilitaire dans le r\u00e9pertoire, Executer la commande app.bat sous Windows, la fen\u00eatre de l'application s'ouvrira. Executer la commande la commande java -jar avec le .jar sous Linux/Mac OS, la fen\u00eatre de l'application s'ouvrira. D\u00e9monstration Sur Windows : Ouverture de l'application : Vous pouvez \u00e9galement (marche en tout cas sur Windows), double-cliquez sur le fichier app.bat , l'application s'ouvrira. Sur Linux/Mac OS: Ex\u00e9cuter le fichier app avec la commande sh Ouverture de l'application : En cas de probl\u00e8me : Si vous \u00eates un utilisateur Mac ou Linux, v\u00e9rifier que vous avez bien les droits sur le fichier pour le lancer. Voici un lien qui explique comment le faire pour : MAC Pour Mac : Solution Mac LINUX Pour Linux : Solution LINUX Remarque : il se peut que vous rencontrez des probl\u00e8mes avec le .jar car l'application utilise un fichier CSS ainsi que des images se trouvant dans src/main/resources .","title":"Installation"},{"location":"installation.html#executer-lapplication","text":"","title":"\u00c9x\u00e9cuter l'application"},{"location":"installation.html#pre-requis","text":"Pour pouvoir utiliser cette application, que vous soyez sur Linux, MAC OS ou Windows, vous devez installer ou poss\u00e9der JAVA JDK8 .","title":"Pr\u00e9-requis"},{"location":"installation.html#distribution-source","text":"","title":"Distribution source"},{"location":"installation.html#depuis-le-fichier-source","text":"Il faut t\u00e9l\u00e9charger la distrubution source qui a \u00e9t\u00e9 d\u00e9pos\u00e9 sur Arche TP3-CHARLES-meteo-0.0.1-SNAPSHOT-project.zip. Voici l'arborescence du projet, une fois d\u00e9zipp\u00e9 :","title":"Depuis le fichier source"},{"location":"installation.html#depuis-github","text":"Pour r\u00e9cup\u00e9rer les fichiers sources depuis le d\u00e9p\u00f4t GIT, il vous faut d'abord cloner ou t\u00e9l\u00e9charger sous format zip :","title":"Depuis GitHub"},{"location":"installation.html#pour-cloner-en-ssh","text":"","title":"Pour cloner en SSH"},{"location":"installation.html#pour-cloner-en-http","text":"Il ne vous reste plus qu'\u00e0 importer votre projet depuis un IDE tel que Eclipse ou IntellJ par exemple.","title":"Pour cloner en HTTP"},{"location":"installation.html#arborescence","text":"scripts/bin : contient les fichiers ex\u00e9cutables (distribution binaire) ; src/main/java/fr/ul/miage/ : contient le code Java (voir Manuel technique).","title":"Arborescence"},{"location":"installation.html#executer-le-programme","text":"Lancer un utilitaire de commandes : Sous Windows : une invite de commandes Sous Linux/Unix/Mac : un terminal \u00c0 l'aide de la commande cd , rendez-vous dans le r\u00e9pertoire o\u00f9 se trouve le .bat , ou ouvrez directement l'utilitaire dans le r\u00e9pertoire, Executer la commande app.bat sous Windows, la fen\u00eatre de l'application s'ouvrira. Executer la commande la commande java -jar avec le .jar sous Linux/Mac OS, la fen\u00eatre de l'application s'ouvrira.","title":"Executer le programme"},{"location":"installation.html#demonstration","text":"","title":"D\u00e9monstration"},{"location":"installation.html#sur-windows","text":"Ouverture de l'application : Vous pouvez \u00e9galement (marche en tout cas sur Windows), double-cliquez sur le fichier app.bat , l'application s'ouvrira.","title":"Sur Windows :"},{"location":"installation.html#sur-linuxmac-os","text":"","title":"Sur Linux/Mac OS:"},{"location":"installation.html#executer-le-fichier-app-avec-la-commande-sh","text":"Ouverture de l'application :","title":"Ex\u00e9cuter le fichier app avec la commande sh"},{"location":"installation.html#en-cas-de-probleme","text":"Si vous \u00eates un utilisateur Mac ou Linux, v\u00e9rifier que vous avez bien les droits sur le fichier pour le lancer. Voici un lien qui explique comment le faire pour :","title":"En cas de probl\u00e8me :"},{"location":"installation.html#mac","text":"Pour Mac : Solution Mac","title":"MAC"},{"location":"installation.html#linux","text":"Pour Linux : Solution LINUX Remarque : il se peut que vous rencontrez des probl\u00e8mes avec le .jar car l'application utilise un fichier CSS ainsi que des images se trouvant dans src/main/resources .","title":"LINUX"},{"location":"licences.html","text":"Licences Ce projet est distribu\u00e9 sous licence UNLICENCE. Ressources et sources utilis\u00e9es pour la documentation MkDocs D\u00e9buter avec MkDocs : source. Configuration de la documentation : source. Maven Configuration de la documentation : source.","title":"Licences"},{"location":"licences.html#licences","text":"Ce projet est distribu\u00e9 sous licence UNLICENCE.","title":"Licences"},{"location":"licences.html#ressources-et-sources-utilisees-pour-la-documentation","text":"","title":"Ressources et sources utilis\u00e9es pour la documentation"},{"location":"licences.html#mkdocs","text":"D\u00e9buter avec MkDocs : source. Configuration de la documentation : source.","title":"MkDocs"},{"location":"licences.html#maven","text":"Configuration de la documentation : source.","title":"Maven"},{"location":"manuelTech.html","text":"La documentation technique Les outils : Pour ce projet j'ai travaill\u00e9 avec les outils suivants : Scene Builder : outil permettant de r\u00e9aliser des interfaces JavaFX (version 8). Eclipse : IDE pour la programmation Java (jdk 1.8_0241). Maven & les plugins n\u00e9cessaires pour g\u00e9n\u00e9rer les fichiers archives et le fichier binaire (inclus avec cette documentation). ObjeAid UML Diagramm : est un outil permettant de cr\u00e9er des diagrammes \u00e0 partir d'Eclipse. Le diagramme de classe : Au vue de la qualit\u00e9 de la photo et du nombres de classes, le diagramme est fournie avec les fichiers sources sous le nom de diagramm_class.ucls . Explications Dans le diagramme, il y a les relations suivantes : Weather : associations avec la classe MeteoClent et la classe Result. List : associations avec les classe Wind, Weather, Rain, Clouds, Sys et Main. Result : associations avec les classes Weather, Wind, Clouds, Coord, Sys et Main. Example : associations avec les classes Weather, List, City et Main. City : association avec la classe Coord. Design Patterns Afin de tester de nouvelles choses, j'ai utilis\u00e9 le design pattern MVC (Mod\u00e8le - Vue - Controller). Les classes : En plus de cette documentation, les classes ont \u00e9t\u00e9 comment\u00e9es avec le plugin permettant la javadoc. App.java Cette classe est la classe principale permettant de lancer l'interface (Baignoire.fxml). Il y a deux m\u00e9thodes : start() : permettant de charger le fichier .fxml , de modifier le titre de la fen\u00eatre (setTitle()), de sp\u00e9cifier le sc\u00e8ne qui va \u00eatre utilis\u00e9 (setScene()), d'afficher la sc\u00e8ne (commande show()). La taille de la fen\u00eatre n'est pas modifiable (avec setResizable()), ceci \u00e9vitant de modifier la taille de la fen\u00eatre et l'affichage a \u00e9t\u00e9 r\u00e9alis\u00e9 de la mani\u00e8re la plus simple possible afin de pouvoir l'afficher sur tous les types d'\u00e9cran (15 pouces, 17 pouces, 19 pouces et inf\u00e9rieur). main() : qui permet de charger la fen\u00eatre avec la commande launch(args) . Model - MeteoClient.java La classe MeteoClient contient 6 param\u00e8tres : WEBSERVICE (String), lang (String), apiKey (String), city (String), country (String). Il y a plusieurs constructeurs ainsi que les getters et setters. buildRequest() : permet de construire une requ\u00eate pour le jour actuel. getJsonWeatherByCityName() : permet de se connecter \u00e0 l'API pour obtenir le r\u00e9sultat de la requ\u00eate pour le jour actuel. Cette requ\u00eate va nous permettre de g\u00e9n\u00e9rer les classes pour acc\u00e9der aux contenus de la requ\u00eate. getWeatherByCityName() : permet construire la requ\u00eate et d'acc\u00e9der aux informations gr\u00e2ce \u00e0 la classe Result . La langue a \u00e9galement \u00e9t\u00e9 modifi\u00e9 afin d'avoir les noms des villes et pays en fran\u00e7ais. buildRequestFor5() : permet de construire une requ\u00eate pour les prochains jours. getWeatherByCityNameFor5() : permet construire la requ\u00eate et d'acc\u00e9der aux informations gr\u00e2ce \u00e0 la classe Example . getJsonWeatherByCityNameFor5() : permet de se connecter \u00e0 l'API pour obtenir le r\u00e9sultat de la requ\u00eate pour les prochins jours. Cette requ\u00eate va nous permettre de g\u00e9n\u00e9rer les classes pour acc\u00e9der aux contenus de la requ\u00eate. Controller - Controller.java initialize() : est la fonction qui s'ex\u00e9cute lorsque la fen\u00e8tre FXML se cr\u00e9\u00e9e. Lors de l'initialisation, on affiche le contenu des labels et des Images en modifiant le contenu avec les m\u00e9thodes setText() et setImage() . On appelle \u00e9galement la fonction loadDataA() , qui permet de charger automatique les villes qui ont \u00e9t\u00e9 sauvegard\u00e9es dans la liste personnalis\u00e9e. diplay(ActionEvent e) : pour chaque MenuItem du menu \"Affichage\", on cherche \u00e0 savoir si le menuItem est s\u00e9lectionn\u00e9 (utilisation de isSelected()) alors si le label est visible (utilisation de isVisible()) alors on le cache ainsi que son image avec la m\u00e9thode setVisible() . Pour d\u00e9clencher la m\u00e9thode, on utilise la m\u00e9thode setOnAction() . setCityResearch(ActionEvent e) : permet de d'afficher les pr\u00e9visions pour une ville contenu dans le menu \"s\u00e9lectionner\". On r\u00e9cup\u00e8re le label du menuItem et on lance la m\u00e9thode checkCityName() . addCityList(ActionEvent e) : si le TextField ville n'est pas vide, on v\u00e9rifie si celui du pays est vide, s'il est vide on r\u00e9cup\u00e8re le texte avec la m\u00e9thode getText() sinon on concat la string r\u00e9cup\u00e9r\u00e9e depuis le TextField ville et celui du pays afin de n'en former plus qu'une seule : nameResearch = nameCity + ',' + nameCountry; On utilse la m\u00e9thode addIntoDelete(string) pour l'ajouter au menu \"supprimer\". Afin d'\u00e9viter les doublons, on parcours la liste de menuItems et on v\u00e9rifie que le dernier \u00e9l\u00e9ment est bien diff\u00e9rent de celui qu'on souhaite ajouter auquel cas, le nouveau menuItem ne sera pas cr\u00e9er sinon on l'ajoute au menu \"s\u00e9lectionner\". Pour r\u00e9cup\u00e9rer le contenu du textField, on utilise la m\u00e9thode \"getText()\" puis pour l'ajouter on l'ajoute au menu concern\u00e9 comme ceci : for (int i = 0; i <= select.getItems().size() ; ++i) { //If the last element isn't not the same the new insert if (stateMenu(select,i,nameResearch) == true) { //LOG.info(newMenu.getText() + \" on ajoute dans select\"); select.getItems().add(newMenu); } } On ajoute \u00e9galement ce menuItem au menu \"supprimer\", pour pouvoir le retirer de la liste personnalis\u00e9e. Au moment o\u00f9 la ville est ajout\u00e9e, on lui donne la possibilit\u00e9 de faire une recherche de pr\u00e9visions pour la ville en question avec les m\u00e9thodes setOnAction() et setCityResearch() . stateMenu(Menu menuCheck,int i, String newAddResearch) : cette fonciton retourne un bool\u00e9en, initialis\u00e9 \u00e0 faux (false). On stock le dernier \u00e9l\u00e9ment de la liste du menu (select ou delete). Si l'\u00e9lement est bien diff\u00e9rent du dernier qui a \u00e9t\u00e9 ajout\u00e9, alors on retourne true, sinon cela reste \u00e0 false. addIntoDelete(String nameCity) : cette methode permet de cr\u00e9er une nouvel menuItem pour le menu \"supprimer\" (en r\u00e8gle g\u00e9n\u00e9rale, il n'est pas possible d'affecter un noeud enfant \u00e0 deux parents diff\u00e9rents, il faut en cr\u00e9er un nouveau), on l'ajoute au menu (m\u00eame principe que pour l'ajouter au menu \"s\u00e9lectionner\" avec v\u00e9rification qu'il n'y ai pas de doublons). Lorsque celui-ci est s\u00e9lectionn\u00e9, cela va entrainer la suppression du menu \"supprimer\" mais aussi du menu \"s\u00e9lectionner\". Pour y arriver, on utilise la m\u00e9thode \"setOnAction()\" dans laquelle on a d\u00e9finit une boucle qui va parcourir le menu select et s'il contient la ville \u00e0 supprimer alors on la retire avec la m\u00e9thode remove() comme ceci : select.getItems().remove(i); On r\u00e9alis\u00e9 alors une nouvelle sauvegarde de la liste afin de mettre \u00e0 jour la liste. saveDataD(Menu menuToSave) : cette methode permet de sauvegarder apr\u00e8s la suppression d'un item du menu. Tout d'abord, nous avons d\u00e9fini une variable path de type String qui contient le chemin relative du fichier nomm\u00e9 backup.txt . On cr\u00e9e ensuite un fichier avec la possibilit\u00e9 de r\u00e9ecrire ce fichier (attribut false) comme ceci : FileWriter writer = new FileWriter(file, false); BufferedWriter bufferedWriter = new BufferedWriter(writer); for (int i = 0; i < menuToSave.getItems().size(); i++) { bufferedWriter.write(menuToSave.getItems().get(i).getText()); bufferedWriter.newLine(); } bufferedWriter.close(); Chaque ligne du menu (le contenu d'un menuItem est r\u00e9cup\u00e9r\u00e9 avec la commande getText()) sera lue et \u00e9crite dans le fichier. On affiche un message afin d'indiquer si la liste a bien \u00e9t\u00e9 mise \u00e0 jour ou non. saveData(MenuItem menuItemToSave) : cette methode permet de sauvegarder apr\u00e8s l'ajout d'un item dans le menu select. Tout d'abord, nous avons d\u00e9fini une variable path de type String qui contient le chemin relative du fichier nomm\u00e9 backup.txt . On cr\u00e9e ensuite un fichier mais celui-ci ne sera pas r\u00e9\u00e9crit \u00e0 chaque fois, car si l'on rajoute une nouvelle ville alors que l'application a \u00e9t\u00e9 ferm\u00e9, cela va conserver uniquement la nouvelle qui vient d'\u00eatre ajout\u00e9, la selection pr\u00e9c\u00e9dente sera alors perdue. C'est pourquoi on met l'attribue true . FileWriter writer = new FileWriter(file, true); BufferedWriter bufferedWriter = new BufferedWriter(writer); bufferedWriter.write(menuItemToSave.getText()); bufferedWriter.newLine(); bufferedWriter.close(); Le contenu du menuItem (le texte) sera alors \u00e9crit dans le fichier \u00e0 la suite du reste.On affiche un message afin d'indiquer si l'ajout c'est bien pass\u00e9 ou pas. loadData(ActionEvent event) : cette methode permet de charger lorsque l'on clique sur \"Recharger\". Pour cela, on va lire le fichier qui a \u00e9t\u00e9 sauvegard\u00e9 avec les m\u00e9thodes pr\u00e9c\u00e9dentes. Si le fichier existe, alors on cr\u00e9e un tampon permettant la lecture, tant que l'on a pas lu toutes les lignes du fichier alors on r\u00e9cup\u00e8re le contenu de la ligne, on en cr\u00e9e un nouveau menu item que l'on ajoute aux menus select et deleteMenu (via la m\u00e9thode addIntoDelete). FileReader reader = new FileReader(path); BufferedReader bufferedReader = new BufferedReader(reader); String line; if (!reload) { while ((line = bufferedReader.readLine()) != null) { reload = true; MenuItem newM = new MenuItem(line); ... } } bufferedReader.close(); On affiche un message afin d'indiquer si les donn\u00e9es ont \u00e9t\u00e9 charg\u00e9 ou si la liste est d\u00e9j\u00e0 \u00e0 jour. loadDataA() : cette m\u00e9thode r\u00e9alise exactement la m\u00eame chose que ce qui a \u00e9t\u00e9 expliqu\u00e9 au dessus, sauf que celle-ci est appel\u00e9 au d\u00e9marrage de l'application, afin que l'utilisateur puisse avoir acc\u00e8s tout suite \u00e0 sa liste, les donn\u00e9es seront d\u00e9j\u00e0 charg\u00e9es. exitScene(ActionEvent e) : permet de quitter la sc\u00e8ne et de stopper le timer si celui-ci est en cours et n'a pas \u00e9t\u00e9 stopp\u00e9 avec la m\u00e9thode stopAct() . stopAct(ActionEvent e) : permet de stopper le timer si celui-ci est en cours, on affiche alors un message afin d'avertir l'utilisateur. Pour stopper le timer, on utilise la m\u00e9thode \"cancel()\". clean(ActionEvent e) : permet de r\u00e9initialiser l'ensemble de l'interface. hideMinMax() : cette m\u00e9thode est utilis\u00e9e dans la m\u00e9thode display() , elle permet de cacher l'image des temp\u00e9ratures Max et Min si les deux sont invisibles sinon si l'un des deux est encore affich\u00e9e, alors l'image reste visible. checkTextFieldCity() : cette m\u00e9thode permet de v\u00e9rifier si le textField n'est pas vide (renvoie un message d'erreur sinon) si on r\u00e9cup\u00e8re le contenu et on appelle la m\u00e9thode \"checkCityName()\". checkCityName(String city) : on cr\u00e9e une nouvelle instance de la classe MeteoCLient et on lui passe dans le contructeur la ville. Si le r\u00e9sultat aboutit \u00e0 une requ\u00eate non null alors on appelle la m\u00e9thode \"displayGUI()\" sion on affiche un message d'erreur via l'interface avec le label result . On met \u00e0 jour l'action en modifiant le label lastUpdate avec la m\u00e9thode getDate() . valider(ActionEvent e) : cette m\u00e9thode est utilis\u00e9e pour d\u00e9chencher l'action lorsque l'on appuie sur le bouton 'Valider'. Cette m\u00e9thode appelle checkTextFieldCity() qui va appeller d'autres m\u00e9thodes, s'il y a une erreur, on l'affiche en console. getTemp(Float nb, Boolean temperature) : cette m\u00e9thode permet de convertir du Farhenheit en Celsius. Dans cette m\u00e9thode, la nombre entr\u00e9 est un float. getTempDouble(String nb, Boolean temperature) : cette m\u00e9thode permet de convertir du Farhenheit en Celsius. Dans cette m\u00e9thode, la nombre entr\u00e9 est une string (permet d'\u00e9viter le cas o\u00f9 la temp\u00e9rature non convertie est un entier plut\u00f4t qu'un double). getDate() : cette m\u00e9thode permet de r\u00e9cup\u00e9rer la date du jour et d'afficher l'heure pour indiquer la derni\u00e8re mise \u00e0 jour. addDays(int nbDays) : permet d'obtenir les dates des jours suivants le jour actuel et de les afficher dans les 'conteneurs' pour les pr\u00e9visions des jours suivants. getTimeSun(long time) : permet d'obtenir sous format heures et minutes, le coucher et le lever du soleil. displayGUI(Result res) : \u00e0 partir de la requ\u00eate, on va pouvoir r\u00e9cup\u00e9rer depuis la classe Result, les informations de la requ\u00eate tel que le vent, les temp\u00e9ratures, la pression etc. On affiche \u00e9galement les \u00eecones en lien avec les donn\u00e9es qui sont dans le repertoire /resources/images/ . getIcon(int nbIcon, JSONObject obj) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant le nom de l'ic\u00f4ne. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, une autre liste contenant les donn\u00e9es dont le nom de l'ic\u00f4ne nomm\u00e9 weather , puis on cherche l'identifiant et on stocke l'objet icon dans une string. getDesciption(int nbDesc, JSONObject obj) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant la description. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, une autre liste contenant les donn\u00e9es dont la description nomm\u00e9 weather , puis on cherche l'identifiant et on stocke l'objet description dans une string. getTempMaxMin(int nbDesc, JSONObject obj, String temp_string) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant la temp\u00e9rature. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, un objet main qui va permettre de retrouner un double \u00e0 partir de s'il s'agit de la temp\u00e9rature max, min, ressentie. displayPrevGUI() : permet d'afficher les pr\u00e9visions des prochains jours. On utilise les m\u00e9thodes addDays() , getTempDOuble() , getTempMaxMin() , getDescription() , getIcon() . Exemple : date2.setText(\"J+1 : \" + addDays(1)); * temp2.setText(getTempDouble(getTempMaxMin(8,obj,\"feels_like\"), true) + \"\u00b0C/\" + getTempDouble(getTempMaxMin(8,obj,\"temp_max\"), true) + \"\u00b0C\"); * descrip2.setText(getDesciption(8,obj)); * imgIcon2.setImage(new Image(\"images/\" + getIcon(8,obj) +\".png\")); * stateTimer() : retourne l'\u00e9tat du timer (bool\u00e9en). stateCity() : retourne un bool\u00e9en pour indiquer si le textField devant r\u00e9cup\u00e9rer la ville est vide ou pas. stateRefresh() : retourne un bool\u00e9en pour indiquer si le textField devant r\u00e9cup\u00e9rer le nombre est vide ou pas. actualise(ActionEvent event) : permet de d\u00e9marrer un timer qui va r\u00e9cup\u00e9rer un nombre en minutes qui va \u00eatre converti en millisecondes. On d\u00e9clenche alors un thread (une t\u00e2che ou TimerTask), qui va recharg\u00e9 les informations de l'interface, mettre \u00e0 jour la maj tout les X minutes. Auquel cas, on retourne une Exception avec le message d'erreur (nombre invalide, saisir les deux champs etc). Afin que l'interface ne lague pas, on utilise la m\u00e9thode runLater() qui permet de rafra\u00eechir plus tard l'interface et de ne pas cr\u00e9er d'exception li\u00e9 au Thread. JSON \u00c0 partir de la requ\u00eate JSON (getJsonWeatherByCityName() et getJsonWeatherByCityNameFor5()), on peut g\u00e9n\u00e9r\u00e9r les classes qui nous permettent d'acc\u00e9der directement aux \u00e9lements sans avoir besoin de parser en JSON la requ\u00eate (j'ai d\u00fb r\u00e9alis\u00e9 quand m\u00eame la manoeuvre pour les pr\u00e9visions des jours suivants). Nous obtenons les classes suivantes : City Clouds Coord Example List Main Rain Result Sys Weather Wind Ces classes comportent essentiellement des getters et des setters permettant d'acc\u00e9der aux contenus de la requ\u00eate, comme par exemple : Dans la classe Result, on peut d'acc\u00e9der au contenu de Main avec la m\u00e9thode getMain() depuis cette m\u00e9thode, r\u00e9cup\u00e9rer par exemple l'humidit\u00e9 avec la m\u00e9thode getHumidity() . View - Window.fxml Il s'agit d'une fen\u00eatre .fmxl cr\u00e9e \u00e0 partir du logiciel SceneBuilder depuis Eclipse . Afin de positionner les \u00e9lements, j'ai utilis\u00e9 une VBox, un SplitPane et des AnchorPanes. Les diff\u00e9rents \u00e9l\u00e9ments de l'interface : Menubar comprenant 3 menus : affichage, ma liste, param\u00e8tres. Affichage : humidit\u00e9 (MenuItem), pression (MenuItem), vent (MenuItem), temp\u00e9rature Max (MenuItem), temp\u00e9rature Min (MenuItem), ressentie (MenuItem), lever (MenuItem), coucher (MenuItem). Ma liste : s\u00e9lectionner (Menu), ajouter (MenuItem), supprimer (Menu). Param\u00e8tres : nettoyer (MenuItem), actualisation arr\u00eat (MenuItem), quitter (MenuItem). Button Valider : permet d'avoir les pr\u00e9visions pour la ville renseign\u00e9e. Button Actualiser : permet d'actualiser toutes les X minutes l'interface. TextField city : permet de renseigner la ville. TextField country : permet de renseigner le pays. TextField refresh : permet de renseigner le nombre de minutes. label lastUpdate : permet de retourner la date et l'heure de la derni\u00e8re action. label result : retourne un message pour indiquer si la recherche s'est bien pass\u00e9 ou un message d'erreur. Pour les pr\u00e9visions du jour label cityCountry : affiche la ville et le pays \u00e0 partir du TextField. label temperature : affiche la temp\u00e9rature. label description : affiche la description de la m\u00e9t\u00e9o. label tempMax : affiche la temp\u00e9rature maximale. label tempMin : affiche la temp\u00e9rature minimale. label humidity : affiche le taux d'humidit\u00e9. label wind : affiche la vitesse du vent (en m/s). label sunrise : affiche l'heure de lever du soleil. label sunset : affiche l'heure du coucher du soleil. label pressure : affiche la pression en hPa. label alterTemp : affiche la temp\u00e9rature ressentie. ImageView imgMinMax : image en lien avec les temp\u00e9ratures max et min. ImageView imgTemp : image en lien avec l'icon de la requ\u00eate. ImageView imgWind : image en lien avec le vent. ImageView imgSunrise : image en lien avec le lever du soleil. ImageView imgSunset : image en lien avec le coucher du soleil. ImageView imgWeather : image en lien avec l'humidit\u00e9. ImageView imgAlter : image en lien avec la temp\u00e9rature ressentie. ImageView imgPres : image en lien avec la pression. Pour les pr\u00e9visions sur 4 jours : Il s'agit de 4 Anchorpanes avec chacun contenant : label dateX : la date du jour +X. label tempX : la temp\u00e9rature du jour +X. ImageView imgIconX : l'icon du jour +X. label descrpX : la description de la m\u00e9t\u00e9o +X. Le POM XML Le pom.xml contient le mod\u00e8le objet pour ce projet. Il contient toutes les informations importantes sur ce projet. Il permet de r\u00e9f\u00e9rencer le groupId, artifactId, version, nom, description, etc. Mais \u00e9galement d'y ajouter des plugins et d\u00e9pendances pour compiler les ressources du projet permettant d'obtenir le .bat ou encore la possibilit\u00e9 de g\u00e9n\u00e9rer des archives (.zip,.rar) avec un .Jar . Dans le POM.XML, l'encondage est d\u00e9finie en UTF-8, d\u00e9fini dans properties : Dans le POM.XML, la version de Java, d\u00e9finie dans dependencies : Les d\u00e9pendances ci-dessus permettent de lire et r\u00e9cup\u00e9rer les informations des requ\u00eates JSON. Celles ci-dessus sont utilis\u00e9s pour la JAVADOC ainsi que pour l'utilisation des outils pour la lecture et l'\u00e9criture des fichiers ( java.io ). les plugins permet de g\u00e9n\u00e9rer automatiquement la distribution binaire du projet, dans le dossier scripts \u00e0 la racine du projet. Cette g\u00e9n\u00e9ration est fix\u00e9e \u00e0 l'\u00e9tape package de Maven . Am\u00e9liorations possibles Optimisation du code (avec d'autres design patterns); embellir l'interface (se baser sur les applications mobiles); faire du refactoring.","title":"Manuel technique"},{"location":"manuelTech.html#la-documentation-technique","text":"","title":"La documentation technique"},{"location":"manuelTech.html#les-outils","text":"Pour ce projet j'ai travaill\u00e9 avec les outils suivants : Scene Builder : outil permettant de r\u00e9aliser des interfaces JavaFX (version 8). Eclipse : IDE pour la programmation Java (jdk 1.8_0241). Maven & les plugins n\u00e9cessaires pour g\u00e9n\u00e9rer les fichiers archives et le fichier binaire (inclus avec cette documentation). ObjeAid UML Diagramm : est un outil permettant de cr\u00e9er des diagrammes \u00e0 partir d'Eclipse.","title":"Les outils :"},{"location":"manuelTech.html#le-diagramme-de-classe","text":"Au vue de la qualit\u00e9 de la photo et du nombres de classes, le diagramme est fournie avec les fichiers sources sous le nom de diagramm_class.ucls .","title":"Le diagramme de classe :"},{"location":"manuelTech.html#explications","text":"Dans le diagramme, il y a les relations suivantes : Weather : associations avec la classe MeteoClent et la classe Result. List : associations avec les classe Wind, Weather, Rain, Clouds, Sys et Main. Result : associations avec les classes Weather, Wind, Clouds, Coord, Sys et Main. Example : associations avec les classes Weather, List, City et Main. City : association avec la classe Coord.","title":"Explications"},{"location":"manuelTech.html#design-patterns","text":"Afin de tester de nouvelles choses, j'ai utilis\u00e9 le design pattern MVC (Mod\u00e8le - Vue - Controller).","title":"Design Patterns"},{"location":"manuelTech.html#les-classes","text":"En plus de cette documentation, les classes ont \u00e9t\u00e9 comment\u00e9es avec le plugin permettant la javadoc.","title":"Les classes :"},{"location":"manuelTech.html#appjava","text":"Cette classe est la classe principale permettant de lancer l'interface (Baignoire.fxml). Il y a deux m\u00e9thodes : start() : permettant de charger le fichier .fxml , de modifier le titre de la fen\u00eatre (setTitle()), de sp\u00e9cifier le sc\u00e8ne qui va \u00eatre utilis\u00e9 (setScene()), d'afficher la sc\u00e8ne (commande show()). La taille de la fen\u00eatre n'est pas modifiable (avec setResizable()), ceci \u00e9vitant de modifier la taille de la fen\u00eatre et l'affichage a \u00e9t\u00e9 r\u00e9alis\u00e9 de la mani\u00e8re la plus simple possible afin de pouvoir l'afficher sur tous les types d'\u00e9cran (15 pouces, 17 pouces, 19 pouces et inf\u00e9rieur). main() : qui permet de charger la fen\u00eatre avec la commande launch(args) .","title":"App.java"},{"location":"manuelTech.html#model-meteoclientjava","text":"La classe MeteoClient contient 6 param\u00e8tres : WEBSERVICE (String), lang (String), apiKey (String), city (String), country (String). Il y a plusieurs constructeurs ainsi que les getters et setters. buildRequest() : permet de construire une requ\u00eate pour le jour actuel. getJsonWeatherByCityName() : permet de se connecter \u00e0 l'API pour obtenir le r\u00e9sultat de la requ\u00eate pour le jour actuel. Cette requ\u00eate va nous permettre de g\u00e9n\u00e9rer les classes pour acc\u00e9der aux contenus de la requ\u00eate. getWeatherByCityName() : permet construire la requ\u00eate et d'acc\u00e9der aux informations gr\u00e2ce \u00e0 la classe Result . La langue a \u00e9galement \u00e9t\u00e9 modifi\u00e9 afin d'avoir les noms des villes et pays en fran\u00e7ais. buildRequestFor5() : permet de construire une requ\u00eate pour les prochains jours. getWeatherByCityNameFor5() : permet construire la requ\u00eate et d'acc\u00e9der aux informations gr\u00e2ce \u00e0 la classe Example . getJsonWeatherByCityNameFor5() : permet de se connecter \u00e0 l'API pour obtenir le r\u00e9sultat de la requ\u00eate pour les prochins jours. Cette requ\u00eate va nous permettre de g\u00e9n\u00e9rer les classes pour acc\u00e9der aux contenus de la requ\u00eate.","title":"Model - MeteoClient.java"},{"location":"manuelTech.html#controller-controllerjava","text":"initialize() : est la fonction qui s'ex\u00e9cute lorsque la fen\u00e8tre FXML se cr\u00e9\u00e9e. Lors de l'initialisation, on affiche le contenu des labels et des Images en modifiant le contenu avec les m\u00e9thodes setText() et setImage() . On appelle \u00e9galement la fonction loadDataA() , qui permet de charger automatique les villes qui ont \u00e9t\u00e9 sauvegard\u00e9es dans la liste personnalis\u00e9e. diplay(ActionEvent e) : pour chaque MenuItem du menu \"Affichage\", on cherche \u00e0 savoir si le menuItem est s\u00e9lectionn\u00e9 (utilisation de isSelected()) alors si le label est visible (utilisation de isVisible()) alors on le cache ainsi que son image avec la m\u00e9thode setVisible() . Pour d\u00e9clencher la m\u00e9thode, on utilise la m\u00e9thode setOnAction() . setCityResearch(ActionEvent e) : permet de d'afficher les pr\u00e9visions pour une ville contenu dans le menu \"s\u00e9lectionner\". On r\u00e9cup\u00e8re le label du menuItem et on lance la m\u00e9thode checkCityName() . addCityList(ActionEvent e) : si le TextField ville n'est pas vide, on v\u00e9rifie si celui du pays est vide, s'il est vide on r\u00e9cup\u00e8re le texte avec la m\u00e9thode getText() sinon on concat la string r\u00e9cup\u00e9r\u00e9e depuis le TextField ville et celui du pays afin de n'en former plus qu'une seule : nameResearch = nameCity + ',' + nameCountry; On utilse la m\u00e9thode addIntoDelete(string) pour l'ajouter au menu \"supprimer\". Afin d'\u00e9viter les doublons, on parcours la liste de menuItems et on v\u00e9rifie que le dernier \u00e9l\u00e9ment est bien diff\u00e9rent de celui qu'on souhaite ajouter auquel cas, le nouveau menuItem ne sera pas cr\u00e9er sinon on l'ajoute au menu \"s\u00e9lectionner\". Pour r\u00e9cup\u00e9rer le contenu du textField, on utilise la m\u00e9thode \"getText()\" puis pour l'ajouter on l'ajoute au menu concern\u00e9 comme ceci : for (int i = 0; i <= select.getItems().size() ; ++i) { //If the last element isn't not the same the new insert if (stateMenu(select,i,nameResearch) == true) { //LOG.info(newMenu.getText() + \" on ajoute dans select\"); select.getItems().add(newMenu); } } On ajoute \u00e9galement ce menuItem au menu \"supprimer\", pour pouvoir le retirer de la liste personnalis\u00e9e. Au moment o\u00f9 la ville est ajout\u00e9e, on lui donne la possibilit\u00e9 de faire une recherche de pr\u00e9visions pour la ville en question avec les m\u00e9thodes setOnAction() et setCityResearch() . stateMenu(Menu menuCheck,int i, String newAddResearch) : cette fonciton retourne un bool\u00e9en, initialis\u00e9 \u00e0 faux (false). On stock le dernier \u00e9l\u00e9ment de la liste du menu (select ou delete). Si l'\u00e9lement est bien diff\u00e9rent du dernier qui a \u00e9t\u00e9 ajout\u00e9, alors on retourne true, sinon cela reste \u00e0 false. addIntoDelete(String nameCity) : cette methode permet de cr\u00e9er une nouvel menuItem pour le menu \"supprimer\" (en r\u00e8gle g\u00e9n\u00e9rale, il n'est pas possible d'affecter un noeud enfant \u00e0 deux parents diff\u00e9rents, il faut en cr\u00e9er un nouveau), on l'ajoute au menu (m\u00eame principe que pour l'ajouter au menu \"s\u00e9lectionner\" avec v\u00e9rification qu'il n'y ai pas de doublons). Lorsque celui-ci est s\u00e9lectionn\u00e9, cela va entrainer la suppression du menu \"supprimer\" mais aussi du menu \"s\u00e9lectionner\". Pour y arriver, on utilise la m\u00e9thode \"setOnAction()\" dans laquelle on a d\u00e9finit une boucle qui va parcourir le menu select et s'il contient la ville \u00e0 supprimer alors on la retire avec la m\u00e9thode remove() comme ceci : select.getItems().remove(i); On r\u00e9alis\u00e9 alors une nouvelle sauvegarde de la liste afin de mettre \u00e0 jour la liste. saveDataD(Menu menuToSave) : cette methode permet de sauvegarder apr\u00e8s la suppression d'un item du menu. Tout d'abord, nous avons d\u00e9fini une variable path de type String qui contient le chemin relative du fichier nomm\u00e9 backup.txt . On cr\u00e9e ensuite un fichier avec la possibilit\u00e9 de r\u00e9ecrire ce fichier (attribut false) comme ceci : FileWriter writer = new FileWriter(file, false); BufferedWriter bufferedWriter = new BufferedWriter(writer); for (int i = 0; i < menuToSave.getItems().size(); i++) { bufferedWriter.write(menuToSave.getItems().get(i).getText()); bufferedWriter.newLine(); } bufferedWriter.close(); Chaque ligne du menu (le contenu d'un menuItem est r\u00e9cup\u00e9r\u00e9 avec la commande getText()) sera lue et \u00e9crite dans le fichier. On affiche un message afin d'indiquer si la liste a bien \u00e9t\u00e9 mise \u00e0 jour ou non. saveData(MenuItem menuItemToSave) : cette methode permet de sauvegarder apr\u00e8s l'ajout d'un item dans le menu select. Tout d'abord, nous avons d\u00e9fini une variable path de type String qui contient le chemin relative du fichier nomm\u00e9 backup.txt . On cr\u00e9e ensuite un fichier mais celui-ci ne sera pas r\u00e9\u00e9crit \u00e0 chaque fois, car si l'on rajoute une nouvelle ville alors que l'application a \u00e9t\u00e9 ferm\u00e9, cela va conserver uniquement la nouvelle qui vient d'\u00eatre ajout\u00e9, la selection pr\u00e9c\u00e9dente sera alors perdue. C'est pourquoi on met l'attribue true . FileWriter writer = new FileWriter(file, true); BufferedWriter bufferedWriter = new BufferedWriter(writer); bufferedWriter.write(menuItemToSave.getText()); bufferedWriter.newLine(); bufferedWriter.close(); Le contenu du menuItem (le texte) sera alors \u00e9crit dans le fichier \u00e0 la suite du reste.On affiche un message afin d'indiquer si l'ajout c'est bien pass\u00e9 ou pas. loadData(ActionEvent event) : cette methode permet de charger lorsque l'on clique sur \"Recharger\". Pour cela, on va lire le fichier qui a \u00e9t\u00e9 sauvegard\u00e9 avec les m\u00e9thodes pr\u00e9c\u00e9dentes. Si le fichier existe, alors on cr\u00e9e un tampon permettant la lecture, tant que l'on a pas lu toutes les lignes du fichier alors on r\u00e9cup\u00e8re le contenu de la ligne, on en cr\u00e9e un nouveau menu item que l'on ajoute aux menus select et deleteMenu (via la m\u00e9thode addIntoDelete). FileReader reader = new FileReader(path); BufferedReader bufferedReader = new BufferedReader(reader); String line; if (!reload) { while ((line = bufferedReader.readLine()) != null) { reload = true; MenuItem newM = new MenuItem(line); ... } } bufferedReader.close(); On affiche un message afin d'indiquer si les donn\u00e9es ont \u00e9t\u00e9 charg\u00e9 ou si la liste est d\u00e9j\u00e0 \u00e0 jour. loadDataA() : cette m\u00e9thode r\u00e9alise exactement la m\u00eame chose que ce qui a \u00e9t\u00e9 expliqu\u00e9 au dessus, sauf que celle-ci est appel\u00e9 au d\u00e9marrage de l'application, afin que l'utilisateur puisse avoir acc\u00e8s tout suite \u00e0 sa liste, les donn\u00e9es seront d\u00e9j\u00e0 charg\u00e9es. exitScene(ActionEvent e) : permet de quitter la sc\u00e8ne et de stopper le timer si celui-ci est en cours et n'a pas \u00e9t\u00e9 stopp\u00e9 avec la m\u00e9thode stopAct() . stopAct(ActionEvent e) : permet de stopper le timer si celui-ci est en cours, on affiche alors un message afin d'avertir l'utilisateur. Pour stopper le timer, on utilise la m\u00e9thode \"cancel()\". clean(ActionEvent e) : permet de r\u00e9initialiser l'ensemble de l'interface. hideMinMax() : cette m\u00e9thode est utilis\u00e9e dans la m\u00e9thode display() , elle permet de cacher l'image des temp\u00e9ratures Max et Min si les deux sont invisibles sinon si l'un des deux est encore affich\u00e9e, alors l'image reste visible. checkTextFieldCity() : cette m\u00e9thode permet de v\u00e9rifier si le textField n'est pas vide (renvoie un message d'erreur sinon) si on r\u00e9cup\u00e8re le contenu et on appelle la m\u00e9thode \"checkCityName()\". checkCityName(String city) : on cr\u00e9e une nouvelle instance de la classe MeteoCLient et on lui passe dans le contructeur la ville. Si le r\u00e9sultat aboutit \u00e0 une requ\u00eate non null alors on appelle la m\u00e9thode \"displayGUI()\" sion on affiche un message d'erreur via l'interface avec le label result . On met \u00e0 jour l'action en modifiant le label lastUpdate avec la m\u00e9thode getDate() . valider(ActionEvent e) : cette m\u00e9thode est utilis\u00e9e pour d\u00e9chencher l'action lorsque l'on appuie sur le bouton 'Valider'. Cette m\u00e9thode appelle checkTextFieldCity() qui va appeller d'autres m\u00e9thodes, s'il y a une erreur, on l'affiche en console. getTemp(Float nb, Boolean temperature) : cette m\u00e9thode permet de convertir du Farhenheit en Celsius. Dans cette m\u00e9thode, la nombre entr\u00e9 est un float. getTempDouble(String nb, Boolean temperature) : cette m\u00e9thode permet de convertir du Farhenheit en Celsius. Dans cette m\u00e9thode, la nombre entr\u00e9 est une string (permet d'\u00e9viter le cas o\u00f9 la temp\u00e9rature non convertie est un entier plut\u00f4t qu'un double). getDate() : cette m\u00e9thode permet de r\u00e9cup\u00e9rer la date du jour et d'afficher l'heure pour indiquer la derni\u00e8re mise \u00e0 jour. addDays(int nbDays) : permet d'obtenir les dates des jours suivants le jour actuel et de les afficher dans les 'conteneurs' pour les pr\u00e9visions des jours suivants. getTimeSun(long time) : permet d'obtenir sous format heures et minutes, le coucher et le lever du soleil. displayGUI(Result res) : \u00e0 partir de la requ\u00eate, on va pouvoir r\u00e9cup\u00e9rer depuis la classe Result, les informations de la requ\u00eate tel que le vent, les temp\u00e9ratures, la pression etc. On affiche \u00e9galement les \u00eecones en lien avec les donn\u00e9es qui sont dans le repertoire /resources/images/ . getIcon(int nbIcon, JSONObject obj) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant le nom de l'ic\u00f4ne. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, une autre liste contenant les donn\u00e9es dont le nom de l'ic\u00f4ne nomm\u00e9 weather , puis on cherche l'identifiant et on stocke l'objet icon dans une string. getDesciption(int nbDesc, JSONObject obj) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant la description. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, une autre liste contenant les donn\u00e9es dont la description nomm\u00e9 weather , puis on cherche l'identifiant et on stocke l'objet description dans une string. getTempMaxMin(int nbDesc, JSONObject obj, String temp_string) : permet de r\u00e9cup\u00e9rer les \u00eecones pour les pr\u00e9visions des jours suivants et de retourner une string contenant la temp\u00e9rature. On y acc\u00e8de via l'objet JSON depuis la liste list , on recherche dans cette liste, un objet main qui va permettre de retrouner un double \u00e0 partir de s'il s'agit de la temp\u00e9rature max, min, ressentie. displayPrevGUI() : permet d'afficher les pr\u00e9visions des prochains jours. On utilise les m\u00e9thodes addDays() , getTempDOuble() , getTempMaxMin() , getDescription() , getIcon() . Exemple : date2.setText(\"J+1 : \" + addDays(1)); * temp2.setText(getTempDouble(getTempMaxMin(8,obj,\"feels_like\"), true) + \"\u00b0C/\" + getTempDouble(getTempMaxMin(8,obj,\"temp_max\"), true) + \"\u00b0C\"); * descrip2.setText(getDesciption(8,obj)); * imgIcon2.setImage(new Image(\"images/\" + getIcon(8,obj) +\".png\")); * stateTimer() : retourne l'\u00e9tat du timer (bool\u00e9en). stateCity() : retourne un bool\u00e9en pour indiquer si le textField devant r\u00e9cup\u00e9rer la ville est vide ou pas. stateRefresh() : retourne un bool\u00e9en pour indiquer si le textField devant r\u00e9cup\u00e9rer le nombre est vide ou pas. actualise(ActionEvent event) : permet de d\u00e9marrer un timer qui va r\u00e9cup\u00e9rer un nombre en minutes qui va \u00eatre converti en millisecondes. On d\u00e9clenche alors un thread (une t\u00e2che ou TimerTask), qui va recharg\u00e9 les informations de l'interface, mettre \u00e0 jour la maj tout les X minutes. Auquel cas, on retourne une Exception avec le message d'erreur (nombre invalide, saisir les deux champs etc). Afin que l'interface ne lague pas, on utilise la m\u00e9thode runLater() qui permet de rafra\u00eechir plus tard l'interface et de ne pas cr\u00e9er d'exception li\u00e9 au Thread.","title":"Controller - Controller.java"},{"location":"manuelTech.html#json","text":"\u00c0 partir de la requ\u00eate JSON (getJsonWeatherByCityName() et getJsonWeatherByCityNameFor5()), on peut g\u00e9n\u00e9r\u00e9r les classes qui nous permettent d'acc\u00e9der directement aux \u00e9lements sans avoir besoin de parser en JSON la requ\u00eate (j'ai d\u00fb r\u00e9alis\u00e9 quand m\u00eame la manoeuvre pour les pr\u00e9visions des jours suivants). Nous obtenons les classes suivantes : City Clouds Coord Example List Main Rain Result Sys Weather Wind Ces classes comportent essentiellement des getters et des setters permettant d'acc\u00e9der aux contenus de la requ\u00eate, comme par exemple : Dans la classe Result, on peut d'acc\u00e9der au contenu de Main avec la m\u00e9thode getMain() depuis cette m\u00e9thode, r\u00e9cup\u00e9rer par exemple l'humidit\u00e9 avec la m\u00e9thode getHumidity() .","title":"JSON"},{"location":"manuelTech.html#view-windowfxml","text":"Il s'agit d'une fen\u00eatre .fmxl cr\u00e9e \u00e0 partir du logiciel SceneBuilder depuis Eclipse . Afin de positionner les \u00e9lements, j'ai utilis\u00e9 une VBox, un SplitPane et des AnchorPanes. Les diff\u00e9rents \u00e9l\u00e9ments de l'interface : Menubar comprenant 3 menus : affichage, ma liste, param\u00e8tres. Affichage : humidit\u00e9 (MenuItem), pression (MenuItem), vent (MenuItem), temp\u00e9rature Max (MenuItem), temp\u00e9rature Min (MenuItem), ressentie (MenuItem), lever (MenuItem), coucher (MenuItem). Ma liste : s\u00e9lectionner (Menu), ajouter (MenuItem), supprimer (Menu). Param\u00e8tres : nettoyer (MenuItem), actualisation arr\u00eat (MenuItem), quitter (MenuItem). Button Valider : permet d'avoir les pr\u00e9visions pour la ville renseign\u00e9e. Button Actualiser : permet d'actualiser toutes les X minutes l'interface. TextField city : permet de renseigner la ville. TextField country : permet de renseigner le pays. TextField refresh : permet de renseigner le nombre de minutes. label lastUpdate : permet de retourner la date et l'heure de la derni\u00e8re action. label result : retourne un message pour indiquer si la recherche s'est bien pass\u00e9 ou un message d'erreur.","title":"View - Window.fxml"},{"location":"manuelTech.html#pour-les-previsions-du-jour","text":"label cityCountry : affiche la ville et le pays \u00e0 partir du TextField. label temperature : affiche la temp\u00e9rature. label description : affiche la description de la m\u00e9t\u00e9o. label tempMax : affiche la temp\u00e9rature maximale. label tempMin : affiche la temp\u00e9rature minimale. label humidity : affiche le taux d'humidit\u00e9. label wind : affiche la vitesse du vent (en m/s). label sunrise : affiche l'heure de lever du soleil. label sunset : affiche l'heure du coucher du soleil. label pressure : affiche la pression en hPa. label alterTemp : affiche la temp\u00e9rature ressentie. ImageView imgMinMax : image en lien avec les temp\u00e9ratures max et min. ImageView imgTemp : image en lien avec l'icon de la requ\u00eate. ImageView imgWind : image en lien avec le vent. ImageView imgSunrise : image en lien avec le lever du soleil. ImageView imgSunset : image en lien avec le coucher du soleil. ImageView imgWeather : image en lien avec l'humidit\u00e9. ImageView imgAlter : image en lien avec la temp\u00e9rature ressentie. ImageView imgPres : image en lien avec la pression.","title":"Pour les pr\u00e9visions du jour"},{"location":"manuelTech.html#pour-les-previsions-sur-4-jours","text":"Il s'agit de 4 Anchorpanes avec chacun contenant : label dateX : la date du jour +X. label tempX : la temp\u00e9rature du jour +X. ImageView imgIconX : l'icon du jour +X. label descrpX : la description de la m\u00e9t\u00e9o +X.","title":"Pour les pr\u00e9visions sur 4 jours :"},{"location":"manuelTech.html#le-pom-xml","text":"Le pom.xml contient le mod\u00e8le objet pour ce projet. Il contient toutes les informations importantes sur ce projet. Il permet de r\u00e9f\u00e9rencer le groupId, artifactId, version, nom, description, etc. Mais \u00e9galement d'y ajouter des plugins et d\u00e9pendances pour compiler les ressources du projet permettant d'obtenir le .bat ou encore la possibilit\u00e9 de g\u00e9n\u00e9rer des archives (.zip,.rar) avec un .Jar . Dans le POM.XML, l'encondage est d\u00e9finie en UTF-8, d\u00e9fini dans properties : Dans le POM.XML, la version de Java, d\u00e9finie dans dependencies : Les d\u00e9pendances ci-dessus permettent de lire et r\u00e9cup\u00e9rer les informations des requ\u00eates JSON. Celles ci-dessus sont utilis\u00e9s pour la JAVADOC ainsi que pour l'utilisation des outils pour la lecture et l'\u00e9criture des fichiers ( java.io ). les plugins permet de g\u00e9n\u00e9rer automatiquement la distribution binaire du projet, dans le dossier scripts \u00e0 la racine du projet. Cette g\u00e9n\u00e9ration est fix\u00e9e \u00e0 l'\u00e9tape package de Maven .","title":"Le POM XML"},{"location":"manuelTech.html#ameliorations-possibles","text":"Optimisation du code (avec d'autres design patterns); embellir l'interface (se baser sur les applications mobiles); faire du refactoring.","title":"Am\u00e9liorations possibles"},{"location":"manuelUt.html","text":"Liste des fonctionnalit\u00e9s Interface de l'application M\u00e9t\u00e9o 1) Chercher les pr\u00e9visions pour une ville (en France) En rentrant le nom d'une ville, vous pouvez obtenir les pr\u00e9visions du jour ainsi que celles des 4 prochains jours (l'API ne permet d'avoir que les pr\u00e9visions des 5 prochains jours en version gratuite). Peu importe l'\u00e9criture (majuscule ou minucule), tant que la ville est bien \u00e9crite, la recherche se d\u00e9roulera sans probl\u00e8me, cliquez ensuite sur le bouton Valider , auquel cas, vous aurez un message d'erreur. Pour les villes fran\u00e7aises, vous n'avez pas besoin de renseigner obligatoirement le pays (FR). R\u00e9sultat : Si vous souhaitez rechercher une autre ville dans un autre pays, vous devez en plus renseigner le pays, exemple : ville : Tokyo, pays : JP. Ville internationale : Mise \u00e0 jour faite le 07/05/2020 : Il est d\u00e9sormais possible de sauvegarder et charger sa liste personnalis\u00e9e. C'est-\u00e0-dire, s'il s'agit de votre premi\u00e8re utilisation, vous n'aurez pas de fichier mais il sera g\u00e9n\u00e9r\u00e9 automatiquement lors de votre premier ajout (vous ins\u00e9rez une ville sachant que Paris,FR est un exemple afin de montrer \u00e0 l'utilisateur comment utiliser l'application). Dans le cadre d'un projet professionnel, il ne doit pas y avoir de choix impossable \u00e0 l'utilisateur, cet onglet servant d'aide pour ce TP. Le chargement des donn\u00e9es sauvegard\u00e9es est automatique lors du lancement de l'application, il en va de m\u00eame pour la sauvegarde (lors d'un ajout ou d'une suppresion). Concernant le code couleur des messages de l'application: Vert : l'action s'est d\u00e9roul\u00e9e sans probl\u00e8me, par exemple vous avez fait une recherche. Bleu : message pour avertir l'utilisateur d'un changement, par exemple vous avez supprim\u00e9 un \u00e9l\u00e9ment de votre liste. Rouge : erreur avec l'application, par exemple vous n'avez pas de sauvegarde existante en lien avec votre application. Si vous avez ce message : Pas de panique , c'est juste que vous n'avez pas encore de fichier de sauvegarde, il sera alors cr\u00e9\u00e9 lors de vos ajouts. Un fois votre ville ins\u00e9r\u00e9e , vous aurez alors ce message : Si vous supprimez une ville de votre liste, vous aurez alors ce message : 2) Rafra\u00eechir pour obtenir les pr\u00e9visions de la ville toutes les X minutes Il est possible de demander un rafra\u00eechissement de l'interface toutes les X minutes. Rentrer un nombre : Cliquez sur le bouton \"Actualiser\" : Et c'est parti ! Une fois que vous avez cliqu\u00e9 sur le bouton, un nouveau message s'affichera en vous indiquant qu'une nouvelle actualisation est en cours. La date de mise \u00e0 jour sera actualis\u00e9e toutes les X minutes. Stopper l'actualisation Dans la barre de navigation, cliquez sur \"Param\u00e8tres\" > \"Actualisation arr\u00eat\" pour stopper le timer. Vous aurez alors un message pour vous dire que vous avez bien stopp\u00e9 l'actualisation comme ci-dessous : Exemple : Nettoyer l'interface Dans la barre de navigation, cliquez sur \"Param\u00e8tres\" > \"Nettoyer\" pour remettre \u00e0 0 l'application. Vous aurez un message en bleu pour vous avertir qu'il n'y a aucune recherche car tout a \u00e9t\u00e9 r\u00e9initialis\u00e9. Recharger Si vous n'avez pas encore ferm\u00e9 l'application et que vous souhaitez restaurer la derni\u00e8re version (version au moment de l'ouverture de l'application), vous pouvez cliquer sur \"Param\u00e8tres\" > \"Recharger\". Si votre application est d\u00e9j\u00e0 \u00e0 jour, vous aurez alors ce message : 3) Personnaliser l'affichage Vous pouvez \u00e0 tout moment, vous pouvez dans le menu \"Affichage\" et d\u00e9finir les options \u00e0 afficher : Remarque : pour que l'image de thermom\u00e8tre disparraisse, il faut que le temp\u00e9ratures max et min soient \"Disable\" toutes les deux. Exemple : Exemple pour les temp\u00e9ratures \"MinMax\" : 4) La liste personnalis\u00e9e Dans le menu \"Ma liste\", il y a 3 options qui sont : S\u00e9lectionner Ajouter Supprimer S\u00e9lectionner : permet depuis la liste de faire une recherche des pr\u00e9visions m\u00e9t\u00e9o d'une ville. Ajouter : ajouter une ville dans la liste depuis le / les champs de texte. Lorsque vous ajoutez une ville / une ville internationale, celle-ci sera sauvegard\u00e9 dans un fichier texte, qui sera recharg\u00e9 automatique lors du red\u00e9larrage de votre application. Supprimer : supprimer une ville / une ville internationale de la liste personnalis\u00e9e. Lorsque vous supprimez une ville / une ville internationale, les villes seront alors actualis\u00e9es lors de votre prochain chargement. S\u00e9lectionner Ajouter Comme expliquer plus haut, il n'est pas n\u00e9cessaire de renseigner le pays, pour les villes en France, par contre si vous souhaitez ajouter une autre ville, il faut renseigner le pays comme ci-dessous: Supprimer Remarque : si une ville est supprim\u00e9e, elle est supprim\u00e9e d\u00e9finitivement de la s\u00e9lection, il est possible de l'ajouter \u00e0 nouveau. Les messages d'erreurs Voici-ci dessous quelques exemples de messages d'erreurs. Pour actualiser : Remarque : le message s'active si les champs sont vides ou incorrectes. Si l'entr\u00e9e pour le nombre de minutes n'est pas un entier alors l'actualisation n'aura pas lieu. Pour valider : Pour la selection : Remarque : si une ville n'existe pas mais qu'elle est ajout\u00e9e \u00e0 la liste, un message d'erreur sera retourn\u00e9 \u00e0 l'utilisateur afin de l'avertir que sa recherche ne sera pas valide. Pour l'exemple ci-dessus, on a ajout\u00e9 Dallas sans renseigner le pays (US). Pour le rechargement des donn\u00e9es : Cel\u00e0 signifie qu'il est impossible de sauvegarder car le fichier n'existe pas ou a \u00e9t\u00e9 supprim\u00e9. Vous devez alors relancer l'application.","title":"Manuel d'utilisiation"},{"location":"manuelUt.html#liste-des-fonctionnalites","text":"","title":"Liste des fonctionnalit\u00e9s"},{"location":"manuelUt.html#interface-de-lapplication-meteo","text":"","title":"Interface de l'application M\u00e9t\u00e9o"},{"location":"manuelUt.html#1-chercher-les-previsions-pour-une-ville-en-france","text":"En rentrant le nom d'une ville, vous pouvez obtenir les pr\u00e9visions du jour ainsi que celles des 4 prochains jours (l'API ne permet d'avoir que les pr\u00e9visions des 5 prochains jours en version gratuite). Peu importe l'\u00e9criture (majuscule ou minucule), tant que la ville est bien \u00e9crite, la recherche se d\u00e9roulera sans probl\u00e8me, cliquez ensuite sur le bouton Valider , auquel cas, vous aurez un message d'erreur. Pour les villes fran\u00e7aises, vous n'avez pas besoin de renseigner obligatoirement le pays (FR). R\u00e9sultat : Si vous souhaitez rechercher une autre ville dans un autre pays, vous devez en plus renseigner le pays, exemple : ville : Tokyo, pays : JP. Ville internationale :","title":"1) Chercher les pr\u00e9visions pour une ville (en France)"},{"location":"manuelUt.html#mise-a-jour-faite-le-07052020","text":"Il est d\u00e9sormais possible de sauvegarder et charger sa liste personnalis\u00e9e. C'est-\u00e0-dire, s'il s'agit de votre premi\u00e8re utilisation, vous n'aurez pas de fichier mais il sera g\u00e9n\u00e9r\u00e9 automatiquement lors de votre premier ajout (vous ins\u00e9rez une ville sachant que Paris,FR est un exemple afin de montrer \u00e0 l'utilisateur comment utiliser l'application). Dans le cadre d'un projet professionnel, il ne doit pas y avoir de choix impossable \u00e0 l'utilisateur, cet onglet servant d'aide pour ce TP. Le chargement des donn\u00e9es sauvegard\u00e9es est automatique lors du lancement de l'application, il en va de m\u00eame pour la sauvegarde (lors d'un ajout ou d'une suppresion). Concernant le code couleur des messages de l'application: Vert : l'action s'est d\u00e9roul\u00e9e sans probl\u00e8me, par exemple vous avez fait une recherche. Bleu : message pour avertir l'utilisateur d'un changement, par exemple vous avez supprim\u00e9 un \u00e9l\u00e9ment de votre liste. Rouge : erreur avec l'application, par exemple vous n'avez pas de sauvegarde existante en lien avec votre application. Si vous avez ce message : Pas de panique , c'est juste que vous n'avez pas encore de fichier de sauvegarde, il sera alors cr\u00e9\u00e9 lors de vos ajouts. Un fois votre ville ins\u00e9r\u00e9e , vous aurez alors ce message : Si vous supprimez une ville de votre liste, vous aurez alors ce message :","title":"Mise \u00e0 jour faite le 07/05/2020 :"},{"location":"manuelUt.html#2-rafraichir-pour-obtenir-les-previsions-de-la-ville-toutes-les-x-minutes","text":"Il est possible de demander un rafra\u00eechissement de l'interface toutes les X minutes.","title":"2) Rafra\u00eechir pour obtenir les pr\u00e9visions de la ville toutes les X minutes"},{"location":"manuelUt.html#rentrer-un-nombre","text":"","title":"Rentrer un nombre :"},{"location":"manuelUt.html#cliquez-sur-le-bouton-actualiser","text":"","title":"Cliquez sur le bouton \"Actualiser\" :"},{"location":"manuelUt.html#et-cest-parti","text":"Une fois que vous avez cliqu\u00e9 sur le bouton, un nouveau message s'affichera en vous indiquant qu'une nouvelle actualisation est en cours. La date de mise \u00e0 jour sera actualis\u00e9e toutes les X minutes.","title":"Et c'est parti !"},{"location":"manuelUt.html#stopper-lactualisation","text":"Dans la barre de navigation, cliquez sur \"Param\u00e8tres\" > \"Actualisation arr\u00eat\" pour stopper le timer. Vous aurez alors un message pour vous dire que vous avez bien stopp\u00e9 l'actualisation comme ci-dessous :","title":"Stopper l'actualisation"},{"location":"manuelUt.html#exemple","text":"","title":"Exemple :"},{"location":"manuelUt.html#nettoyer-linterface","text":"Dans la barre de navigation, cliquez sur \"Param\u00e8tres\" > \"Nettoyer\" pour remettre \u00e0 0 l'application. Vous aurez un message en bleu pour vous avertir qu'il n'y a aucune recherche car tout a \u00e9t\u00e9 r\u00e9initialis\u00e9.","title":"Nettoyer l'interface"},{"location":"manuelUt.html#recharger","text":"Si vous n'avez pas encore ferm\u00e9 l'application et que vous souhaitez restaurer la derni\u00e8re version (version au moment de l'ouverture de l'application), vous pouvez cliquer sur \"Param\u00e8tres\" > \"Recharger\". Si votre application est d\u00e9j\u00e0 \u00e0 jour, vous aurez alors ce message :","title":"Recharger"},{"location":"manuelUt.html#3-personnaliser-laffichage","text":"Vous pouvez \u00e0 tout moment, vous pouvez dans le menu \"Affichage\" et d\u00e9finir les options \u00e0 afficher : Remarque : pour que l'image de thermom\u00e8tre disparraisse, il faut que le temp\u00e9ratures max et min soient \"Disable\" toutes les deux.","title":"3) Personnaliser l'affichage"},{"location":"manuelUt.html#exemple_1","text":"","title":"Exemple :"},{"location":"manuelUt.html#exemple-pour-les-temperatures-minmax","text":"","title":"Exemple pour les temp\u00e9ratures \"MinMax\" :"},{"location":"manuelUt.html#4-la-liste-personnalisee","text":"Dans le menu \"Ma liste\", il y a 3 options qui sont : S\u00e9lectionner Ajouter Supprimer S\u00e9lectionner : permet depuis la liste de faire une recherche des pr\u00e9visions m\u00e9t\u00e9o d'une ville. Ajouter : ajouter une ville dans la liste depuis le / les champs de texte. Lorsque vous ajoutez une ville / une ville internationale, celle-ci sera sauvegard\u00e9 dans un fichier texte, qui sera recharg\u00e9 automatique lors du red\u00e9larrage de votre application. Supprimer : supprimer une ville / une ville internationale de la liste personnalis\u00e9e. Lorsque vous supprimez une ville / une ville internationale, les villes seront alors actualis\u00e9es lors de votre prochain chargement.","title":"4) La liste personnalis\u00e9e"},{"location":"manuelUt.html#selectionner","text":"","title":"S\u00e9lectionner"},{"location":"manuelUt.html#ajouter","text":"Comme expliquer plus haut, il n'est pas n\u00e9cessaire de renseigner le pays, pour les villes en France, par contre si vous souhaitez ajouter une autre ville, il faut renseigner le pays comme ci-dessous:","title":"Ajouter"},{"location":"manuelUt.html#supprimer","text":"Remarque : si une ville est supprim\u00e9e, elle est supprim\u00e9e d\u00e9finitivement de la s\u00e9lection, il est possible de l'ajouter \u00e0 nouveau.","title":"Supprimer"},{"location":"manuelUt.html#les-messages-derreurs","text":"Voici-ci dessous quelques exemples de messages d'erreurs.","title":"Les messages d'erreurs"},{"location":"manuelUt.html#pour-actualiser","text":"Remarque : le message s'active si les champs sont vides ou incorrectes. Si l'entr\u00e9e pour le nombre de minutes n'est pas un entier alors l'actualisation n'aura pas lieu.","title":"Pour actualiser :"},{"location":"manuelUt.html#pour-valider","text":"","title":"Pour valider :"},{"location":"manuelUt.html#pour-la-selection","text":"Remarque : si une ville n'existe pas mais qu'elle est ajout\u00e9e \u00e0 la liste, un message d'erreur sera retourn\u00e9 \u00e0 l'utilisateur afin de l'avertir que sa recherche ne sera pas valide. Pour l'exemple ci-dessus, on a ajout\u00e9 Dallas sans renseigner le pays (US).","title":"Pour la selection :"},{"location":"manuelUt.html#pour-le-rechargement-des-donnees","text":"Cel\u00e0 signifie qu'il est impossible de sauvegarder car le fichier n'existe pas ou a \u00e9t\u00e9 supprim\u00e9. Vous devez alors relancer l'application.","title":"Pour le rechargement des donn\u00e9es :"},{"location":"tests.html","text":"Liste des tests unitaires Les tests unitaires se trouve dans le dossier source, vous pouvez consulter le fichier TestsUnitaires.java depuis src/test/java . Veuillez vous assurer que vous pouvez utiliser JUnit sur votre IDE auquel cas r\u00e9f\u00e9rez vous \u00e0 la documentation de votre IDE. Test sur testTemp() On cherche \u00e0 v\u00e9rifier si la temp\u00e9rature calcul\u00e9e avec la m\u00e9thode getTemp() est bien \u00e9gale \u00e0 la temp\u00e9rature donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Pour cet exemple, on v\u00e9rifie que 286.16 vaut bien bien, une fois convertie, 13.01. Test sur testTempDouble() On cherche \u00e0 v\u00e9rifier si la temp\u00e9rature calcul\u00e9e avec la m\u00e9thode getTempDouble() est bien \u00e9gale \u00e0 la temp\u00e9rature donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Pour cet exemple, on v\u00e9rifie que 286.14 vaut bien bien, une fois convertie, 12.99. Test sur testTempDouble1() Il s'agit du m\u00eame test au dessus, \u00e0 la place de la valeur \u00e0 tester, il s'agit d'une valeur enti\u00e8re, on teste avec 290 et on v\u00e9rifie que le r\u00e9sultat est bien \u00e9gale \u00e0 16.85 (il se peut que la requ\u00eate JSON contient des nombres entiers, la fonction a \u00e9t\u00e9 adapt\u00e9 pour pouvoir lire les doubles ainsi que les integers). Test sur testDate() On cherche \u00e0 v\u00e9rifier si l'la date calcul\u00e9e avec la m\u00e9thode getDate() est bien \u00e9gale \u00e0 la date donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testTempSun() On cherche \u00e0 v\u00e9rifier si l'heure calcul\u00e9e avec la m\u00e9thode getTimeSun() est bien \u00e9gale \u00e0 l'heure donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testCity() On cherche \u00e0 v\u00e9rifier si la ville trouv\u00e9e avec la m\u00e9thode getCity() est bien la m\u00eame ville que celle initialis\u00e9e. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testCountry() On cherche \u00e0 v\u00e9rifier si le pays trouv\u00e9 avec la m\u00e9thode getCountry() est bien le m\u00eame pays que celui initialis\u00e9. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testApiKey() On cherche \u00e0 v\u00e9rifier si la ville trouv\u00e9e avec la m\u00e9thode getApiKey() est bien la m\u00eame cl\u00e9 que celle initialis\u00e9e. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testTimer() On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateTimer() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testStateCity() On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateCity() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertTrue() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Test sur testStateRefresh() On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateRefresh() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertNotNull() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Tests"},{"location":"tests.html#liste-des-tests-unitaires","text":"Les tests unitaires se trouve dans le dossier source, vous pouvez consulter le fichier TestsUnitaires.java depuis src/test/java . Veuillez vous assurer que vous pouvez utiliser JUnit sur votre IDE auquel cas r\u00e9f\u00e9rez vous \u00e0 la documentation de votre IDE.","title":"Liste des tests unitaires"},{"location":"tests.html#test-sur-testtemp","text":"On cherche \u00e0 v\u00e9rifier si la temp\u00e9rature calcul\u00e9e avec la m\u00e9thode getTemp() est bien \u00e9gale \u00e0 la temp\u00e9rature donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Pour cet exemple, on v\u00e9rifie que 286.16 vaut bien bien, une fois convertie, 13.01.","title":"Test sur testTemp()"},{"location":"tests.html#test-sur-testtempdouble","text":"On cherche \u00e0 v\u00e9rifier si la temp\u00e9rature calcul\u00e9e avec la m\u00e9thode getTempDouble() est bien \u00e9gale \u00e0 la temp\u00e9rature donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames. Pour cet exemple, on v\u00e9rifie que 286.14 vaut bien bien, une fois convertie, 12.99.","title":"Test sur testTempDouble()"},{"location":"tests.html#test-sur-testtempdouble1","text":"Il s'agit du m\u00eame test au dessus, \u00e0 la place de la valeur \u00e0 tester, il s'agit d'une valeur enti\u00e8re, on teste avec 290 et on v\u00e9rifie que le r\u00e9sultat est bien \u00e9gale \u00e0 16.85 (il se peut que la requ\u00eate JSON contient des nombres entiers, la fonction a \u00e9t\u00e9 adapt\u00e9 pour pouvoir lire les doubles ainsi que les integers).","title":"Test sur testTempDouble1()"},{"location":"tests.html#test-sur-testdate","text":"On cherche \u00e0 v\u00e9rifier si l'la date calcul\u00e9e avec la m\u00e9thode getDate() est bien \u00e9gale \u00e0 la date donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testDate()"},{"location":"tests.html#test-sur-testtempsun","text":"On cherche \u00e0 v\u00e9rifier si l'heure calcul\u00e9e avec la m\u00e9thode getTimeSun() est bien \u00e9gale \u00e0 l'heure donn\u00e9e sans la m\u00e9thode. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testTempSun()"},{"location":"tests.html#test-sur-testcity","text":"On cherche \u00e0 v\u00e9rifier si la ville trouv\u00e9e avec la m\u00e9thode getCity() est bien la m\u00eame ville que celle initialis\u00e9e. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testCity()"},{"location":"tests.html#test-sur-testcountry","text":"On cherche \u00e0 v\u00e9rifier si le pays trouv\u00e9 avec la m\u00e9thode getCountry() est bien le m\u00eame pays que celui initialis\u00e9. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testCountry()"},{"location":"tests.html#test-sur-testapikey","text":"On cherche \u00e0 v\u00e9rifier si la ville trouv\u00e9e avec la m\u00e9thode getApiKey() est bien la m\u00eame cl\u00e9 que celle initialis\u00e9e. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testApiKey()"},{"location":"tests.html#test-sur-testtimer","text":"On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateTimer() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertEquals() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testTimer()"},{"location":"tests.html#test-sur-teststatecity","text":"On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateCity() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertTrue() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testStateCity()"},{"location":"tests.html#test-sur-teststaterefresh","text":"On cherche \u00e0 v\u00e9rifier si le bool\u00e9en retourn\u00e9 avec la m\u00e9thode stateRefresh() correspond \u00e0 celui attendu. On utilise la m\u00e9thode assertNotNull() permet de v\u00e9rifier que les deux r\u00e9sultats sont bien les m\u00eames.","title":"Test sur testStateRefresh()"}]}